+++
title = "Domain-Driven Design"
author = ["Hillfolk"]
date = 2020-07-06
lastmod = 2020-07-06T21:55:39+09:00
tags = ["domain-driven-design", "ddd", "도메인", "드리븐", "디자인"]
categories = ["posts"]
draft = true
weight = 100
+++

## 동작하는 도메인 만들기 {#동작하는-도메인-만들기}

도메인(domain): 사용자가 사용하는 프로그램을 사용하는 영역
도메인 모델: 도메인 지식을 엄격하게 구성하고 선택적으로 추상화 하는 것

-   도메인 주도 설계에서 모델의 유용성
    1.  모델과 핵심 설계는 서로 영향을 주며 구체화 된다.
        모델을 의미 있게 만들고 모델의 분석이 최종 산출물인 동작하는 프로그램에 적용 되게끔 보장하는 것이 다름 아닌 모델과 구현간의 긴밀한 연결이다. 이러한 모델과 구현의 연결은 유지보수와 계속되는 기능 개선에도 도움이 되는데 그 이유는 바로 모델을 이해한 바에 근거해 코드를 해석할 수 있기 때문이다.
    2.  모델은 모든 팀 구성원이 사용하는 언어의 중추다.
        모델과 구현이 서로 연결되 있으므로 개발자는 이 언어를 토대로 프로그램에 관해 의견을 나눌 수 있다. 그러므로 개발자와 도메인 전문가가 의샅소통하는데 별도의 번역 절차가 필요하지 않다.
    3.  모델은 지식의 정수만을 뽑아낸 것이다.
        모델은 도메인 지식을 조직화 하고 가장 주요한 요소를 구분하는 팀의 합의된 방식이다. 모델에는 우리가 용어를 선택하고 개념을 분류하며 분류한 지식을 서로 연관시킬 때 도메인에 관한 우리의 사고방식이 담겨 있다. 개발자와 도메인 전문가는 공유 언어를 바탕으로 갖가지 정보를 모델로 만들어 낼때 효과적으로 협업 할 수 있다.  모델과 구현이 연결돼 있다면 초기 버전의 소프트웨어를 통해 얻은 경험을 모델링 프로세스에 피드백으로 활용할 수 있다.

-   소프트웨어의 본질
    소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있다.
    그 나머지는 부수적인 요소에 불과하다.


## 도메인 이란? {#도메인-이란}

도메인의 사전적 의미는 “정보와 활동의 영역” 을 말하며 특정 소프트웨어로 소프트웨어로 해결 하고자 하는 문제 영역 이다.


### 도메인 모델 {#도메인-모델}

특정 도메인을 개념적으로 표현한 것으로 객체 기반 다이어그램 상태 기반 다이어그램 등의 다양한 방식으로 모델링이 가능하다. 도메인을 적합하게 표현한다면 어떤 표현 방식이라도 가능하다.
도메인 모델은 기본적으로 개념 모델이며 이것을 가지고 바로 코드를 작성하지 못한다. 각 개발 환경에 맞는 구현모델이 필요하며 구현 모델은 개념 모델을 최대한 따르 도록 한다.


#### 도메인 모델 도출 {#도메인-모델-도출}

도메인 모델은 기회서 유즈 케이스 사용자 스토리와 같은 요구사항과 관ㄹ녀자와의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델의 초안을 도출 한다. 개인적으노는 도메인 모델 설계시에는 사용자의 도메인 요구사항을 한 문장으로 정의하여 제약 사항을 정의한다.

-   최소 한 종류 이상의 상품을 주문해야 한다.
-   한 상품을 한개 이상 주문할 수 있다.
-   총 주문 급액은 각  상품 구매 가격의 합을 모두 더한 금액이다.
-   각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
-   주문할 때 매송지 정보를 만드시 지정해야 한다.
-   출고를 하면 배송지 정보를 벼녁ㅇ 할 수 없다.
-   출고 전에는 주문을 취소 할수 있다.

이러한 제약사항을 가지고 각 모델의 관련 기능을 함수로 정의 할수 있다.

```golang
type Order interface {
    ChangeShipped() err
    ChangeShippingInfo(ShippingInfo info) err
    Cancel() err
}
```


#### Entity와 Value {#entity와-value}

도출한 모델은 크게 Entity 와 Value 로 구문할 수 있으며 요구 사항 분석 과정에서도 Entity 와 Value 를 구분하여 설계한다.

<!--list-separator-->

-  Entity

    고유 식별자를 가지는 모델로서 상태가 변경 되더라도 식별자는 변경되지 않는다. 엔티티의 식별자가 같으면 같은 엔티티로 판단한다. 엔티티의 식별자를 생성하는 시점은 도메인에 따라 다르며 생성 방식은 아래 4가지를 주로 사용한다. 용도에 따라서 적정하게 선택하여 사용하면 된다.

    -   특정 규칙에 따라 생성
    -   UUID 사용
    -   값을 직접 입력
    -   일련 번호 사용 (시퀀스 또는 자동 증가값)

<!--list-separator-->

-  Value

    식별자를 가지지 않은 값 으로서 개념적인 완전한 하나의 값을 표현 불변 타입을 사용할경우 보다 안전한 코드 작성이 가능하다.(받는 사람 , 어드레스 ,전화번호) 밸류 타입은 일반적은 데이터 타입을 사용하기 보다는 도메인 데이터 타입을 사용자 정의 하여 사용하는것이 도메인 표현과 코드 가독성에 도움이 된다. 벨류 타입은 값을 변경하기 보다는 새로운 밸류를 생성하는 방식을 선호 하며 각 객체는 불변으로 유지 하는것이 안전한 코드에 도움이 된다.


#### 도메인 용어 {#도메인-용어}

코드를 작성 할때는 도메인에서 사용하는 용어를 사용하느 것이 매우 중요하다. 도메인에서 사용하는 용어를 코드의 사용하지 않을 경우 개발자와 사용자의 커뮤니케이션이 잘못될 수 있다.


## 일반적인 도메인 주도 아키텍처 개요 {#일반적인-도메인-주도-아키텍처-개요}


## 어그리게이트 (aggregate) {#어그리게이트--aggregate}


## 리포지터리 {#리포지터리}


## 응용 서비스 표현 영역 {#응용-서비스-표현-영역}


## 도메인 서비스 {#도메인-서비스}


## 어그리게이트와 트랜젝션 관리 {#어그리게이트와-트랜젝션-관리}


## 도메인 모델과 BOUNDED CONTEXT {#도메인-모델과-bounded-context}


## 이벤트 {#이벤트}


## CQRS {#cqrs}
