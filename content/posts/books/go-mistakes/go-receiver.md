+++
title = "Go 에서 적합한 리시버 타입의 결정 하기"
author = ["Hillfolk"]
date = 2024-02-26
lastmod = 2024-02-26T16:35:26+09:00
tags = ["golang", "Go", "Mistakes"]
categories = ["posts"]
draft = false
weight = 100
+++

## 적합한 리시버 타입을 결정하라. {#적합한-리시버-타입을-결정하라-dot}

Go를 사용하면서 가장 애매한 순간이 리시버로 값을 사용할지 포인터를 사용할지 많은 고민을 하게 된다. 이번에 읽는 책에서 좋은 내용이 있어서 요약 공유 하려고 한다. 대부분 아는 내용이겠지만 이렇게 명확하게 정의하니 순간 순간 고민을 줄일 수 있고 생각 못했던 내용도 있어 유용한다.


### 리시버가 반드시 포인터여야 하는 경우 {#리시버가-반드시-포인터여야-하는-경우}

1.  가장 단순한 케이스로 메서드에서 리시버의 값을 변경해야 하는 경우로 리시버가 슬라이스고, 메서드에서 원소를 추가하는 경우도 동일한다.
2.  메서드 리시버에 복제할 수 없는 필드가 있는 경우는 리시버를 포인터로 사용해야 한다. 책에서는 예로 sync 타입을 들어서 설명하고 있다.


### 포린터 리시버가 바람직한 경우 {#포린터-리시버가-바람직한-경우}

1.  리시버가 큰 오브젝트일때 포인터를 사용하면 복제 작업으로 인한 성능 저하를 피할 수 있어서 효율을 높일 수 있다. 적당한 크기의 경우는 각 상황에 따라서 다르다. 하지만 빈번하게 사용된다면 성능 측정을 통해서 복사의 성능을 점검할 필요가 있다.


### 리시버가 반드시 값이어야 하는 경우 {#리시버가-반드시-값이어야-하는-경우}

1.  리시버의 불변성을 보장해야 하는경우
2.  리시버가 맵이나 함수, 채널인 경우 그외 경우는 컴퍼일러 에러가 발생한다.


### 값 리시버가 바람직한 경우 {#값-리시버가-바람직한-경우}

1.  값이 변하지 않아도 되는 슬라이스로 된 경우
2.  리시버가 적은 배열이나 구조체라서 가변 필드가 없은 값 타입의 경우
3.  리시버가 int,float64, string 같은 기본 타입인 경우

[100 Go Mistakes](https://product.kyobobook.co.kr/detail/S000211704725) Go 에 관심있다면 꼭 읽어볼만한 책으로 보인다.
